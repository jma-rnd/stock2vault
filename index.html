<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vault vs Stock Drawing Audit</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #101833;
      --panel2: #0f1630;
      --text: #e9eefc;
      --muted: #b7c0df;
      --muted2: #8d97bd;
      --accent: #6aa8ff;
      --good: #5ee38f;
      --warn: #ffcc66;
      --bad: #ff6a8a;
      --border: rgba(255,255,255,.09);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --radius2: 12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--text);
      background: radial-gradient(1200px 800px at 20% 0%, rgba(106,168,255,.18), transparent 55%),
                  radial-gradient(900px 700px at 80% 15%, rgba(94,227,143,.12), transparent 55%),
                  linear-gradient(180deg, var(--bg), #070a14);
      min-height: 100vh;
    }

    header {
      padding: 22px 22px 0 22px;
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: .2px;
    }
    .sub {
      margin-top: 8px;
      color: var(--muted);
      line-height: 1.35;
      font-size: 14px;
      max-width: 900px;
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px 22px 28px 22px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card .head {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      background: rgba(0,0,0,.18);
    }

    .card .head h2 {
      margin: 0;
      font-size: 15px;
      font-weight: 650;
    }

    .pill {
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.14);
      white-space: nowrap;
    }

    .body {
      padding: 14px 16px 16px 16px;
    }

    .uploader {
      display: grid;
      gap: 10px;
    }

    input[type="file"] {
      width: 100%;
      padding: 12px;
      border-radius: var(--radius2);
      border: 1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.15);
      color: var(--muted);
      outline: none;
    }

    .hint {
      color: var(--muted2);
      font-size: 13px;
      line-height: 1.35;
    }

    .kvs {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 12px;
    }

    .sectionTitle {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: .14em;
      color: var(--muted2);
      margin: 14px 0 8px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.14);
      font-size: 12px;
      color: var(--text);
      max-width: 100%;
    }

    .chip .mono {
      font-family: var(--mono);
      color: var(--muted);
      font-size: 11px;
    }

    .gridFull { grid-column: 1 / -1; }

    .toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .toolbar .left,
    .toolbar .right {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid var(--border);
      background: rgba(106,168,255,.12);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 650;
    }

    button.secondary {
      background: rgba(255,255,255,.06);
    }

    button:disabled {
      opacity: .55;
      cursor: not-allowed;
    }

    .search {
      width: min(420px, 100%);
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline: none;
    }

    .list {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
      background: rgba(0,0,0,.12);
    }

    .listHeader {
      display: grid;
      grid-template-columns: 44px 1fr 110px;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      background: rgba(0,0,0,.16);
    }

    .row {
      display: grid;
      grid-template-columns: 44px 1fr 110px;
      gap: 10px;
      padding: 10px 12px;
      align-items: center;
      border-bottom: 1px solid rgba(255,255,255,.06);
    }
    .row:last-child { border-bottom: none; }

    .row .name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .count {
      font-family: var(--mono);
      color: var(--muted);
      text-align: right;
    }

    .muted { color: var(--muted); }
    .ok { color: var(--good); font-weight: 650; }
    .warn { color: var(--warn); font-weight: 650; }
    .error { color: var(--bad); font-weight: 650; }

    .footerNote {
      margin-top: 12px;
      color: var(--muted2);
      font-size: 12px;
      line-height: 1.35;
    }

    /* Review panel */
    .reviewWrap {
      display: grid;
      gap: 10px;
    }

    .reviewItem {
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(0,0,0,.12);
      padding: 12px;
      display: grid;
      gap: 10px;
    }

    .reviewTop {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .badge {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.14);
      white-space: nowrap;
    }

    .reviewBtns {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .reviewBtns button {
      padding: 8px 10px;
      border-radius: 12px;
      font-weight: 700;
    }

    button.good {
      background: rgba(94,227,143,.14);
    }

    button.bad {
      background: rgba(255,106,138,.14);
    }

    .reviewText {
      font-size: 13px;
      line-height: 1.4;
      color: var(--text);
      border: 1px solid rgba(255,255,255,.06);
      border-radius: 12px;
      padding: 10px;
      background: rgba(0,0,0,.14);
    }

    .reviewLabel {
      font-size: 11px;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--muted2);
      margin-bottom: 6px;
    }

    mark.tok {
      background: rgba(106,168,255,.28);
      color: var(--text);
      padding: 1px 3px;
      border-radius: 6px;
    }

    .decision {
      font-weight: 750;
    }

    .decision.approved { color: var(--good); }
    .decision.flagged { color: var(--bad); }

    @media (max-width: 520px) {
      .fdates { grid-template-columns: 1fr; }
    }

    .auditTable {
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow: hidden;
      background: rgba(0,0,0,.12);
    }

    .auditHead, .auditRow {
      display: grid;
      grid-template-columns: 1fr 160px;
      gap: 10px;
      padding: 10px 12px;
      align-items: center;
    }

    .auditHead {
      border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,.16);
      color: var(--muted);
      font-size: 12px;
    }

    .auditRow { border-bottom: 1px solid rgba(255,255,255,.06); }
    .auditRow:last-child { border-bottom: none; }

    .auditRow .cat { font-weight: 650; }
    .auditRow .subtxt {
      display: block;
      margin-top: 2px;
      font-size: 12px;
      color: var(--muted2);
      font-weight: 500;
    }

    .auditRow .num {
      font-family: var(--mono);
      color: var(--text);
      text-align: right;
    }

    .rules {
      margin-bottom: 12px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: rgba(0,0,0,.12);
      padding: 10px 12px;
    }

    .rulesGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    select {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline: none;
    }

    @media (max-width: 520px) {
      .rulesGrid { grid-template-columns: 1fr; }
      .auditHead, .auditRow { grid-template-columns: 1fr 120px; }
    }

    @media (max-width: 980px) {
      .wrap { grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <header>
    <h1>Vault vs Stock Drawing Audit</h1>
    <div class="sub">
      Upload a <b>Stock Movements</b> XLSX and a <b>Vault File Listing</b> XLSX. The app will show detected column headings for each file. For the stock file, it will also summarize <span class="muted">Group Desc</span> values (unique entries + row counts) with checkboxes.
    </div>
  </header>

  <main class="wrap">
    <section class="card">
      <div class="head">
        <h2>1) Stock export</h2>
        <div class="pill" id="stockStatus">No file loaded</div>
      </div>
      <div class="body">
        <div class="uploader">
          <input id="stockFile" type="file" accept=".xlsx,.xls" />
          <div class="hint">
            Expected: columns named <span class="mono">Part Code</span>, <span class="mono">Part Desc</span>, <span class="mono">Group Desc</span>, and <span class="mono">Last Movement Date</span>.
          </div>
        </div>

        <div class="kvs">
          <div>
            <div class="sectionTitle">Detected column headings</div>
            <div class="chips" id="stockHeaders"></div>
          </div>

          <div>
            <div class="sectionTitle">Date filter (Last Movement Date)</div>
            <div class="filters" id="dateFilters">
              <label class="fopt"><input type="checkbox" id="f6m" disabled /> <span>Last 6 months</span></label>
              <label class="fopt"><input type="checkbox" id="f12m" disabled /> <span>Last 12 months</span></label>
              <label class="fopt"><input type="checkbox" id="fcustom" disabled /> <span>Custom</span></label>

              <div class="fdates">
                <div class="fdate">
                  <div class="flabel">Start</div>
                  <input type="date" id="fStart" disabled />
                </div>
                <div class="fdate">
                  <div class="flabel">End</div>
                  <input type="date" id="fEnd" disabled />
                </div>
              </div>

              <div class="fmeta" id="fMeta">Load a stock file to enable date filtering.</div>
            </div>
          </div>

          <div>
            <div class="sectionTitle">Group Desc summary</div>
            <div class="toolbar">
              <div class="left">
                <input class="search" id="groupSearch" placeholder="Search Group Desc…" disabled />
              </div>
              <div class="right">
                <button class="secondary" id="selectAll" disabled>Select all</button>
                <button class="secondary" id="selectNone" disabled>Select none</button>
                <button class="secondary" id="selectDefault" disabled>Default</button>
              </div>
            </div>

            <div class="list" id="groupList" aria-live="polite">
              <div class="listHeader">
                <div></div>
                <div>Group Desc</div>
                <div style="text-align:right;">Rows</div>
              </div>
              <div class="row"><div></div><div class="muted">Load a stock file to see Group Desc values.</div><div></div></div>
            </div>

            <div class="footerNote">
              Tip: this is a lightweight, in-browser audit helper. Nothing is uploaded anywhere; files are processed locally.
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="head">
        <h2>2) Vault export</h2>
        <div class="pill" id="vaultStatus">No file loaded</div>
      </div>
      <div class="body">
        <div class="uploader">
          <input id="vaultFile" type="file" accept=".xlsx,.xls" />
          <div class="hint">
            Expected: columns named <span class="mono">Stock Number</span>, <span class="mono">Filetype</span>, <span class="mono">State</span>, and <span class="mono">Title</span>.
          </div>
        </div>

        <div class="sectionTitle">Detected column headings</div>
        <div class="chips" id="vaultHeaders"></div>

        <div class="sectionTitle">Filetype summary</div>
        <div class="list" id="vaultFiletypeList" aria-live="polite">
          <div class="listHeader" style="grid-template-columns: 1fr 110px;">
            <div>Filetype</div>
            <div style="text-align:right;">Rows</div>
          </div>
          <div class="row" style="grid-template-columns: 1fr 110px;"><div class="muted">Load a vault file to see Filetype values.</div><div></div></div>
        </div>

        <div class="footerNote">
          Next steps we can add: stronger matching rules, drawing/name normalization, and export an audit XLSX.
        </div>
      </div>
    </section>

    <section class="card gridFull" id="auditCard">
      <div class="head">
        <h2>3) Audit output</h2>
        <div class="pill" id="auditStatus">Waiting for files</div>
      </div>
      <div class="body">
        <div class="toolbar" style="margin-bottom:12px;">
          <div class="left">
            <button id="runAudit" disabled>Run audit</button>
            <button class="secondary" id="toggleRules" disabled>Rules</button>
          </div>
          <div class="right">
            <span class="hint" id="auditHint">Load both files to compute results.</span>
          </div>
        </div>

        <div id="rulesPanel" class="rules" style="display:none;">
          <div class="sectionTitle" style="margin-top:0;">Hidden rules panel</div>
          <div class="hint">This panel will become fully customisable. For now the primary association rule is hard-coded: <b>Stock Part Code</b> ↔ <b>Vault Stock Number</b> (case-insensitive exact match).</div>

          <div style="margin-top:10px; display:grid; gap:10px;">
            <label class="fopt" style="margin:0;"><input type="checkbox" id="defaultMatchToggle" checked /> <span><b>Use default association</b> (Part Code ↔ Stock Number)</span></label>
            <div class="fmeta" id="defaultMatchMeta">Active. Matching is exact after trimming and lowercasing (case-insensitive).</div>

            <label class="fopt" style="margin:0;"><input type="checkbox" id="descTitleToggle" /> <span><b>Also try Part Desc ↔ Title</b> (loose word match)</span></label>
            <div class="fmeta" id="descTitleMeta">Off. If enabled, rows that fail the default match will try a word-overlap match between Stock Part Desc and Vault Title.</div>

            <label class="fopt" style="margin:0;"><input type="checkbox" id="descTitleTunableToggle" /> <span><b>Also try Part Desc ↔ Title (tunable)</b> (loose word match)</span></label>
            <div class="fmeta" id="descTitleTunableMeta">Off. If enabled, uses the sliders below to try to reduce false negatives (may increase false positives).</div>

            <div id="tunableControls" style="display:none; gap:10px;">
              <div class="fmeta" style="margin-top:2px;">Thresholds</div>
              <div class="rulesGrid" style="margin-top:0;">
                <div>
                  <div class="flabel">Min shared tokens: <span id="tunableTokVal" class="mono">4</span></div>
                  <input type="range" id="tunableTok" min="1" max="10" step="1" value="4" style="width:100%;" />
                </div>
                <div>
                  <div class="flabel">Min Jaccard: <span id="tunableJacVal" class="mono">0.50</span></div>
                  <input type="range" id="tunableJac" min="0.10" max="0.90" step="0.05" value="0.50" style="width:100%;" />
                </div>
              </div>
            </div>
          </div>

          <div class="rulesGrid" id="manualMatchGrid">
            <div>
              <div class="flabel">Stock match column</div>
              <select id="stockMatchCol" disabled></select>
            </div>
            <div>
              <div class="flabel">Vault match column</div>
              <select id="vaultMatchCol" disabled></select>
            </div>
          </div>
        </div>

        <div class="auditTable" role="table" aria-label="Audit summary">
          <div class="auditHead" role="row">
            <div role="columnheader">Category</div>
            <div role="columnheader" style="text-align:right;">Stock rows</div>
          </div>
          <div id="auditRows"></div>
        </div>

        <div class="footerNote">Categories are mutually exclusive per stock row, based on best available match in Vault.</div>
      </div>
    </section>

    <section class="card gridFull" id="reviewCard" style="display:none;">
      <div class="head">
        <h2>4) Match review</h2>
        <div class="pill" id="reviewStatus">Hidden</div>
      </div>
      <div class="body">
        <div class="toolbar" style="margin-bottom:12px;">
          <div class="left">
            <span class="hint" id="reviewHint">This panel appears only when a Part Desc ↔ Title rule is used.</span>
          </div>
          <div class="right">
            <button class="secondary" id="reviewNext" disabled>Show another 10</button>
          </div>
        </div>

        <div class="reviewWrap" id="reviewList"></div>

        <div class="footerNote">Use this to spot-check and flag false positives so we can improve the rules later.</div>
      </div>
    </section>

    <section class="card gridFull">
      <div class="head">
        <h2>App log</h2>
        <div class="pill" id="logStatus">Ready</div>
      </div>
      <div class="body">
        <div id="log" class="hint" style="white-space:pre-wrap;"></div>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    // -----------------------------
    // State
    // -----------------------------
    const DEFAULT_GROUP_DESCS = [
      'Bolt Components',
      'Bolt Finished Goods',
      'Buy - ins',
      'Civil Buy - ins',
      'Cable Bolt',
      'Cable Components',
      'Cable Raw Material',
      'Civil - Westconnex',
      'Drill Bits & Rods',
      'Friction-Lok',
      'J Bar Raw Material',
      'Low Profile Bolt',
      'Mesh',
      'Plastic Bolts',
      'Plastic Plate',
      'Plate Feed - Steel',
      'Plates - Steel',
      'Raw Material',
      'Rebar Raw Material',
      'Resin Injection',
      'Smooth Rod Raw Materials',
      'Steel Mesh',
      'Tensioners,Footpumps & Com',
      'Washers',
    ];

    const state = {
      audit: {
        useDefaultMatchRule: true,
        useDescTitleRule: false,
        useDescTitleTunableRule: false,
        tunableMinSharedTokens: 4,
        tunableMinJaccard: 0.50,

        stockMatchCol: 'Part Code',
        vaultMatchCol: 'Stock Number',

        stockMatchIdx: -1,
        stockGroupIdx: -1,
        stockDescIdx: -1,
        stockMoveDateIdx: -1,

        vaultMatchIdx: -1,
        vaultTypeIdx: -1,
        vaultStateIdx: -1,
        vaultTitleIdx: -1,

        vaultIndex: new Map(),
        titleTokenIndex: new Map(),
        titleToEntries: new Map(),

        counts: {
          released: 0,
          unreleased: 0,
          pdf: 0,
          modelled: 0,
          folder: 0,
          missing: 0,
          totalConsidered: 0,
        },

        review: {
          items: [],
          cursor: 0,
          decisions: new Map(), // key -> 'approved' | 'flagged'
        },
      },

      stock: {
        fileName: null,
        headers: [],
        rawRows: [],
        rows: [],
        groupCounts: new Map(),
        groupSelected: new Map(),
        dateFilter: {
          mode: 'none',
          start: null,
          end: null,
        },
      },

      vault: {
        fileName: null,
        headers: [],
        rows: [],
      },
    };

    // -----------------------------
    // Elements
    // -----------------------------
    const el = {
      stockFile: document.getElementById('stockFile'),
      vaultFile: document.getElementById('vaultFile'),

      stockStatus: document.getElementById('stockStatus'),
      vaultStatus: document.getElementById('vaultStatus'),

      stockHeaders: document.getElementById('stockHeaders'),
      vaultHeaders: document.getElementById('vaultHeaders'),

      groupList: document.getElementById('groupList'),
      groupSearch: document.getElementById('groupSearch'),
      selectAll: document.getElementById('selectAll'),
      selectNone: document.getElementById('selectNone'),
      selectDefault: document.getElementById('selectDefault'),

      f6m: document.getElementById('f6m'),
      f12m: document.getElementById('f12m'),
      fcustom: document.getElementById('fcustom'),
      fStart: document.getElementById('fStart'),
      fEnd: document.getElementById('fEnd'),
      fMeta: document.getElementById('fMeta'),

      vaultFiletypeList: document.getElementById('vaultFiletypeList'),

      auditStatus: document.getElementById('auditStatus'),
      auditRows: document.getElementById('auditRows'),
      auditHint: document.getElementById('auditHint'),
      runAudit: document.getElementById('runAudit'),
      toggleRules: document.getElementById('toggleRules'),
      rulesPanel: document.getElementById('rulesPanel'),

      defaultMatchToggle: document.getElementById('defaultMatchToggle'),
      defaultMatchMeta: document.getElementById('defaultMatchMeta'),
      descTitleToggle: document.getElementById('descTitleToggle'),
      descTitleMeta: document.getElementById('descTitleMeta'),
      descTitleTunableToggle: document.getElementById('descTitleTunableToggle'),
      descTitleTunableMeta: document.getElementById('descTitleTunableMeta'),
      tunableTok: document.getElementById('tunableTok'),
      tunableTokVal: document.getElementById('tunableTokVal'),
      tunableJac: document.getElementById('tunableJac'),
      tunableJacVal: document.getElementById('tunableJacVal'),
      tunableControls: document.getElementById('tunableControls'),

      stockMatchCol: document.getElementById('stockMatchCol'),
      vaultMatchCol: document.getElementById('vaultMatchCol'),
      manualMatchGrid: document.getElementById('manualMatchGrid'),

      log: document.getElementById('log'),
      reviewCard: document.getElementById('reviewCard'),
      reviewStatus: document.getElementById('reviewStatus'),
      reviewHint: document.getElementById('reviewHint'),
      reviewList: document.getElementById('reviewList'),
      reviewNext: document.getElementById('reviewNext'),

      logStatus: document.getElementById('logStatus'),
    };

    // -----------------------------
    // Helpers
    // -----------------------------
    function clearNode(node) {
      while (node.firstChild) node.removeChild(node.firstChild);
    }

    function log(msg, level='info') {
      const ts = new Date().toLocaleTimeString();
      const prefix = level === 'error' ? '⛔' : level === 'warn' ? '⚠️' : 'ℹ️';
      el.log.textContent = `${prefix} [${ts}] ${msg}\n` + el.log.textContent;
      el.logStatus.textContent = level === 'error' ? 'Error' : level === 'warn' ? 'Warning' : 'OK';
      el.logStatus.className = 'pill ' + (level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'ok');
    }

    function setStatus(which, text, kind='muted') {
      const node = which === 'stock' ? el.stockStatus : el.vaultStatus;
      node.textContent = text;
      node.className = 'pill ' + (kind === 'ok' ? 'ok' : kind === 'warn' ? 'warn' : kind === 'error' ? 'error' : '');
    }

    function setAuditStatus(text, kind='muted') {
      el.auditStatus.textContent = text;
      el.auditStatus.className = 'pill ' + (kind === 'ok' ? 'ok' : kind === 'warn' ? 'warn' : kind === 'error' ? 'error' : '');
    }

    function normalizeHeader(h) {
      return String(h || '').trim().replace(/\s+/g, ' ').toLowerCase();
    }

    function findColumnIndex(headers, desired) {
      const want = normalizeHeader(desired);
      for (let i=0; i<headers.length; i++) {
        if (normalizeHeader(headers[i]) === want) return i;
      }
      return -1;
    }

    function safeCell(row, idx) {
      if (idx < 0) return '';
      return String((row[idx] ?? '')).trim();
    }

    function normalizeKey(v) {
      return String(v || '').trim().toLowerCase();
    }

    function renderChips(target, headers) {
      clearNode(target);
      if (!headers || headers.length === 0) {
        const span = document.createElement('div');
        span.className = 'hint muted';
        span.textContent = 'No headers detected (empty sheet?)';
        target.appendChild(span);
        return;
      }
      headers.forEach((h, i) => {
        const chip = document.createElement('div');
        chip.className = 'chip';
        const name = document.createElement('span');
        name.textContent = String(h || '').trim() || '(blank)';
        const idx = document.createElement('span');
        idx.className = 'mono';
        idx.textContent = `#${i+1}`;
        chip.appendChild(name);
        chip.appendChild(idx);
        target.appendChild(chip);
      });
    }

    function hasNonEmpty(v) {
      return String(v ?? '').trim() !== '';
    }

    function filterRowsByRequiredColumn(rows, idx) {
      if (idx === -1) return { rows, dropped: 0 };
      const out = [];
      let dropped = 0;
      for (const r of rows) {
        if (hasNonEmpty(r[idx])) out.push(r);
        else dropped++;
      }
      return { rows: out, dropped };
    }

    function unique(arr) {
      return Array.from(new Set(arr));
    }

    function escapeHtml(s) {
      return String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function overlapTokenSet(aText, bText) {
      const a = new Set(unique(tokenizeLoose(aText)));
      const b = new Set(unique(tokenizeLoose(bText)));
      const inter = new Set();
      for (const x of a) if (b.has(x)) inter.add(x);
      return inter;
    }

    // Highlight tokens by splitting into alphanumeric runs so we only highlight whole tokens.
    function highlightTokensInText(text, tokenSet) {
      const s = String(text ?? '');
      const parts = s.split(/([a-zA-Z0-9]+)/g);
      let out = '';
      for (const part of parts) {
        if (!part) continue;
        if (/^[a-zA-Z0-9]+$/.test(part)) {
          const k = part.toLowerCase();
          if (tokenSet && tokenSet.has(k)) {
            out += `<mark class="tok">${escapeHtml(part)}</mark>`;
          } else {
            out += escapeHtml(part);
          }
        } else {
          out += escapeHtml(part);
        }
      }
      return out;
    }

    // -----------------------------
    // XLSX parsing
    // -----------------------------
    async function readXlsx(file) {
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type: 'array' });
      const firstSheetName = wb.SheetNames[0];
      const ws = wb.Sheets[firstSheetName];
      if (!ws) return { headers: [], rows: [], sheet: firstSheetName };

      const data = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true, defval: '' });
      if (!data || data.length === 0) return { headers: [], rows: [], sheet: firstSheetName };

      const headers = (data[0] || []).map(h => String(h ?? '').trim());
      const rows = data.slice(1);

      // Trim trailing completely-empty rows (common when Excel has formatting)
      const isEmptyRow = (r) => {
        if (!r) return true;
        for (const cell of r) {
          if (String(cell ?? '').trim() !== '') return false;
        }
        return true;
      };
      let end = rows.length;
      while (end > 0 && isEmptyRow(rows[end - 1])) end--;

      return { headers, rows: rows.slice(0, end), sheet: firstSheetName };
    }

    // -----------------------------
    // Stock: Group Desc + Date filtering
    // -----------------------------
    function computeCounts(rows, idx) {
      const counts = new Map();
      if (idx === -1) return counts;
      for (const r of rows) {
        const key = String((r[idx] ?? '')).trim();
        if (!key) continue;
        counts.set(key, (counts.get(key) || 0) + 1);
      }
      const sorted = Array.from(counts.entries()).sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));
      return new Map(sorted);
    }

    function parseLooseDate(v) {
      if (v == null) return null;
      if (v instanceof Date && !isNaN(v.getTime())) return v;

      // Excel serial
      if (typeof v === 'number' && isFinite(v)) {
        try {
          const d = XLSX.SSF.parse_date_code(v);
          if (d && d.y && d.m && d.d) {
            // Use UTC to avoid timezone drift
            return new Date(Date.UTC(d.y, d.m - 1, d.d));
          }
        } catch (_) {}
      }

      const s = String(v).trim();
      if (!s) return null;

      // YYYY-MM-DD
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
        const [y, m, d] = s.split('-').map(n => Number(n));
        return new Date(Date.UTC(y, m - 1, d));
      }

      // DD/MM/YYYY or D/M/YYYY
      const m1 = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if (m1) {
        const dd = Number(m1[1]);
        const mm = Number(m1[2]);
        const yy = Number(m1[3]);
        return new Date(Date.UTC(yy, mm - 1, dd));
      }

      // Fallback: Date.parse
      const t = Date.parse(s);
      if (!isNaN(t)) return new Date(t);

      return null;
    }

    function setDateFilterMode(mode) {
      state.stock.dateFilter.mode = mode;
      // exclusive checkboxes
      el.f6m.checked = (mode === '6m');
      el.f12m.checked = (mode === '12m');
      el.fcustom.checked = (mode === 'custom');

      const enableCustom = (mode === 'custom');
      el.fStart.disabled = !enableCustom;
      el.fEnd.disabled = !enableCustom;

      updateDateFilterRange();
      scheduleAuditRun();
    }

    function updateDateFilterRange() {
      const mode = state.stock.dateFilter.mode;
      const now = new Date();
      const utcToday = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));

      if (mode === 'none') {
        state.stock.dateFilter.start = null;
        state.stock.dateFilter.end = null;
        el.fMeta.textContent = 'No date filtering applied.';
        return;
      }

      if (mode === '6m' || mode === '12m') {
        const months = (mode === '6m') ? 6 : 12;
        const start = new Date(Date.UTC(utcToday.getUTCFullYear(), utcToday.getUTCMonth() - months, utcToday.getUTCDate()));
        state.stock.dateFilter.start = start;
        state.stock.dateFilter.end = utcToday;
        el.fStart.value = start.toISOString().slice(0,10);
        el.fEnd.value = utcToday.toISOString().slice(0,10);
        el.fMeta.textContent = `Filtering to last ${months} months (inclusive).`;
        return;
      }

      if (mode === 'custom') {
        const start = el.fStart.value ? parseLooseDate(el.fStart.value) : null;
        const end = el.fEnd.value ? parseLooseDate(el.fEnd.value) : null;
        state.stock.dateFilter.start = start;
        state.stock.dateFilter.end = end;
        el.fMeta.textContent = 'Custom date filter applied (inclusive).';
        return;
      }
    }

    function rowPassesDateFilter(row) {
      const mode = state.stock.dateFilter.mode;
      if (mode === 'none') return true;
      const idx = state.audit.stockMoveDateIdx;
      if (idx === -1) return true; // no date column -> don't filter
      const d = parseLooseDate(row[idx]);
      if (!d) return false; // if filtering, rows without a date do not pass

      const start = state.stock.dateFilter.start;
      const end = state.stock.dateFilter.end;
      if (start && d < start) return false;
      if (end && d > end) return false;
      return true;
    }

    function rebuildGroupSelectionDefaultAll() {
      state.stock.groupSelected = new Map();
      for (const [g] of state.stock.groupCounts.entries()) {
        state.stock.groupSelected.set(g, true);
      }
    }

    function applyDefaultGroupSelection() {
      const wanted = new Set(DEFAULT_GROUP_DESCS.map(x => normalizeKey(x)));
      let selected = 0;
      for (const g of state.stock.groupSelected.keys()) {
        const isOn = wanted.has(normalizeKey(g));
        state.stock.groupSelected.set(g, isOn);
        if (isOn) selected++;
      }
      return { selected };
    }

    function renderGroupList() {
      const q = normalizeKey(el.groupSearch.value || '');
      const list = el.groupList;
      clearNode(list);

      const head = document.createElement('div');
      head.className = 'listHeader';
      head.innerHTML = '<div></div><div>Group Desc</div><div style="text-align:right;">Rows</div>';
      list.appendChild(head);

      if (!state.stock.fileName || !state.stock.groupCounts.size) {
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = '<div></div><div class="muted">Load a stock file to see Group Desc values.</div><div></div>';
        list.appendChild(row);
        return;
      }

      let shown = 0;
      for (const [g, cnt] of state.stock.groupCounts.entries()) {
        if (q && !normalizeKey(g).includes(q)) continue;
        shown++;
        const row = document.createElement('div');
        row.className = 'row';

        const cbWrap = document.createElement('div');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = state.stock.groupSelected.get(g) !== false;
        cb.addEventListener('change', () => {
          state.stock.groupSelected.set(g, cb.checked);
          scheduleAuditRun();
        });
        cbWrap.appendChild(cb);

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = g;

        const c = document.createElement('div');
        c.className = 'count';
        c.textContent = String(cnt);

        row.appendChild(cbWrap);
        row.appendChild(name);
        row.appendChild(c);
        list.appendChild(row);
      }

      if (shown === 0) {
        const row = document.createElement('div');
        row.className = 'row';
        row.innerHTML = '<div></div><div class="muted">No Group Desc values match the current search.</div><div></div>';
        list.appendChild(row);
      }
    }

    function getFilteredStockRows() {
      const rows = state.stock.rows || [];
      const gIdx = state.audit.stockGroupIdx;
      const out = [];
      for (const r of rows) {
        // Date filter first
        if (!rowPassesDateFilter(r)) continue;

        // Group filter
        if (gIdx !== -1 && state.stock.groupSelected && state.stock.groupSelected.size) {
          const g = safeCell(r, gIdx);
          if (!g) continue;
          if (state.stock.groupSelected.get(g) === false) continue;
        }
        out.push(r);
      }
      return out;
    }

    // -----------------------------
    // Vault: indexes & filetype summary
    // -----------------------------
    function computeGroupCountsGeneric(rows, idx) {
      const counts = new Map();
      if (idx === -1) return counts;
      for (const r of rows) {
        const key = String((r[idx] ?? '')).trim();
        if (!key) continue;
        counts.set(key, (counts.get(key) || 0) + 1);
      }
      const sorted = Array.from(counts.entries()).sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));
      return new Map(sorted);
    }

    function renderVaultFiletypeSummary() {
      const list = el.vaultFiletypeList;
      if (!list) return;

      clearNode(list);

      const header = document.createElement('div');
      header.className = 'listHeader';
      header.style.gridTemplateColumns = '1fr 110px';
      header.innerHTML = '<div>Filetype</div><div style="text-align:right;">Rows</div>';
      list.appendChild(header);

      if (!state.vault.fileName || !state.vault.headers.length) {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.gridTemplateColumns = '1fr 110px';
        row.innerHTML = '<div class="muted">Load a vault file to see Filetype values.</div><div></div>';
        list.appendChild(row);
        return;
      }

      const ftIdx = findColumnIndex(state.vault.headers, 'Filetype');
      if (ftIdx === -1) {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.gridTemplateColumns = '1fr 110px';
        row.innerHTML = '<div class="muted">Column "Filetype" not found — summary unavailable.</div><div></div>';
        list.appendChild(row);
        return;
      }

      const counts = computeGroupCountsGeneric(state.vault.rows, ftIdx);
      if (!counts.size) {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.gridTemplateColumns = '1fr 110px';
        row.innerHTML = '<div class="muted">No Filetype values found.</div><div></div>';
        list.appendChild(row);
        return;
      }

      for (const [name, count] of counts.entries()) {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.gridTemplateColumns = '1fr 110px';

        const label = document.createElement('div');
        label.className = 'name';
        label.textContent = name;

        const c = document.createElement('div');
        c.className = 'count';
        c.textContent = String(count);

        row.appendChild(label);
        row.appendChild(c);
        list.appendChild(row);
      }
    }

    function updateAuditMappings() {
      state.audit.stockMatchIdx = findColumnIndex(state.stock.headers, state.audit.stockMatchCol || '');
      state.audit.stockGroupIdx = findColumnIndex(state.stock.headers, 'Group Desc');
      state.audit.stockDescIdx = findColumnIndex(state.stock.headers, 'Part Desc');
      state.audit.stockMoveDateIdx = findColumnIndex(state.stock.headers, 'Last Movement Date');

      state.audit.vaultMatchIdx = findColumnIndex(state.vault.headers, state.audit.vaultMatchCol || '');
      state.audit.vaultTypeIdx = findColumnIndex(state.vault.headers, 'Filetype');
      state.audit.vaultStateIdx = findColumnIndex(state.vault.headers, 'State');
      state.audit.vaultTitleIdx = findColumnIndex(state.vault.headers, 'Title');
    }

    // Normalize any path-ish string to a base filename (no directories)
    function stripPath(nameVal) {
      const s = String(nameVal || '').trim();
      const unified = s.split('\\\\').join('/');
      const parts = unified.split('/');
      return parts.length ? parts[parts.length - 1] : unified;
    }

    function baseNameFromAny(nameVal) {
      const just = stripPath(nameVal);
      const low = just.toLowerCase();
      const dot = low.lastIndexOf('.');
      return (dot > 0 ? low.slice(0, dot) : low);
    }

    function detectExt(filetypeVal, nameVal) {
      const t = String(filetypeVal || '').toLowerCase();
      const n = String(nameVal || '').toLowerCase();
      const exts = ['.idw', '.pdf', '.ipt', '.iam'];
      for (const e of exts) {
        if (t.includes(e)) return e;
        if (n.endsWith(e)) return e;
      }
      return '';
    }

    function buildVaultIndex() {
      state.audit.vaultIndex = new Map();
      if (!state.vault.rows.length) return;
      updateAuditMappings();

      const mIdx = state.audit.vaultMatchIdx;
      const tIdx = state.audit.vaultTypeIdx;
      const sIdx = state.audit.vaultStateIdx;

      for (const r of state.vault.rows) {
        const key = normalizeKey(safeCell(r, mIdx));
        if (!key) continue;
        const nameVal = safeCell(r, mIdx);
        const typeVal = safeCell(r, tIdx);
        const stateVal = safeCell(r, sIdx);
        const ext = detectExt(typeVal, nameVal);
        const base = baseNameFromAny(nameVal);
        const entry = { key, name: nameVal, base, ext, filetype: String(typeVal || ''), state: String(stateVal || ''), row: r };
        if (!state.audit.vaultIndex.has(key)) state.audit.vaultIndex.set(key, []);
        state.audit.vaultIndex.get(key).push(entry);
      }
    }

    // -----------------------------
    // Fuzzy: Title matching
    // -----------------------------
    const STOPWORDS = new Set([
      'a','an','and','are','as','at','be','but','by','for','from','has','have','if','in','into','is','it','its','of','on','or','s','such','t','that','the','their','then','there','these','they','this','to','was','will','with'
    ]);

    function tokenizeLoose(s) {
      const text = String(s || '').toLowerCase();
      const raw = text.split(/[^a-z0-9]+/g).filter(Boolean);
      const out = [];

      const splitMixed = (tok) => {
        // Keep short letter+digits identifiers intact (e.g., m12, d10, ab123)
        if (/^[a-z]{1,3}\d{1,6}$/.test(tok)) return [tok];

        // Split number+letters suffix (e.g., 150mm -> 150, mm)
        if (/^\d{1,8}[a-z]{1,4}$/.test(tok)) {
          const m = tok.match(/^(\d{1,8})([a-z]{1,4})$/);
          return m ? [m[1], m[2]] : [tok];
        }

        // General split at letter<->digit boundaries
        const withBars = tok.replace(/([a-z])([0-9])/g, '$1|$2').replace(/([0-9])([a-z])/g, '$1|$2');
        return withBars.split('|').filter(Boolean);
      };

      for (const chunk of raw) {
        const parts = splitMixed(chunk);
        for (const tok of parts) {
          if (tok.length < 3) continue;
          if (STOPWORDS.has(tok)) continue;
          out.push(tok);
        }
      }
      return out;
    }

    function jaccard(aSet, bSet) {
      let inter = 0;
      for (const x of aSet) if (bSet.has(x)) inter++;
      const union = aSet.size + bSet.size - inter;
      return union ? inter / union : 0;
    }

    // Conservative defaults
    const FUZZY_MIN_SHARED_TOKENS = 4;
    const FUZZY_MIN_JACCARD = 0.50;

    function buildTitleIndex() {
      state.audit.titleTokenIndex = new Map();
      state.audit.titleToEntries = new Map();
      if (!state.vault.rows.length) return;
      updateAuditMappings();

      const titleIdx = state.audit.vaultTitleIdx;
      const tIdx = state.audit.vaultTypeIdx;
      const sIdx = state.audit.vaultStateIdx;
      if (titleIdx === -1) return;

      for (const r of state.vault.rows) {
        const titleRaw = safeCell(r, titleIdx);
        const titleKey = normalizeKey(titleRaw);
        if (!titleKey) continue;

        const typeVal = safeCell(r, tIdx);
        const stateVal = safeCell(r, sIdx);

        const ext = detectExt(typeVal, titleRaw);
        const base = baseNameFromAny(titleRaw);

        const entry = { key: titleKey, name: titleRaw, base, ext, filetype: String(typeVal || ''), state: String(stateVal || ''), row: r };

        if (!state.audit.titleToEntries.has(titleKey)) state.audit.titleToEntries.set(titleKey, []);
        state.audit.titleToEntries.get(titleKey).push(entry);

        const toks = unique(tokenizeLoose(titleRaw));
        for (const tok of toks) {
          if (!state.audit.titleTokenIndex.has(tok)) state.audit.titleTokenIndex.set(tok, new Set());
          state.audit.titleTokenIndex.get(tok).add(titleKey);
        }
      }
    }

    function findBestTitleMatch(stockDesc, opts = null) {
      const cfg = {
        minSharedTokens: FUZZY_MIN_SHARED_TOKENS,
        minJaccard: FUZZY_MIN_JACCARD,
        ...(opts || {})
      };

      const toks = unique(tokenizeLoose(stockDesc));
      if (toks.length === 0) return { titleKey: null, score: 0, shared: 0 };

      const candidateCounts = new Map();
      for (const tok of toks) {
        const set = state.audit.titleTokenIndex.get(tok);
        if (!set) continue;
        for (const titleKey of set) {
          candidateCounts.set(titleKey, (candidateCounts.get(titleKey) || 0) + 1);
        }
      }

      let bestKey = null;
      let bestShared = 0;
      let bestScore = 0;

      const aSet = new Set(toks);

      for (const [titleKey, shared] of candidateCounts.entries()) {
        if (shared < cfg.minSharedTokens) continue;
        const entries = state.audit.titleToEntries.get(titleKey);
        if (!entries || entries.length === 0) continue;
        const titleText = entries[0].name;
        const bSet = new Set(unique(tokenizeLoose(titleText)));
        const score = jaccard(aSet, bSet);
        if (score > bestScore || (score === bestScore && shared > bestShared)) {
          bestKey = titleKey;
          bestShared = shared;
          bestScore = score;
        }
      }

      if (!bestKey) return { titleKey: null, score: 0, shared: 0 };
      if (bestShared < cfg.minSharedTokens) return { titleKey: null, score: 0, shared: 0 };
      if (bestScore < cfg.minJaccard) return { titleKey: null, score: 0, shared: 0 };
      return { titleKey: bestKey, score: bestScore, shared: bestShared };
    }

    // -----------------------------
    // Audit classification
    // -----------------------------
    function isReleasedState(stateVal) {
      return normalizeHeader(stateVal) === 'released';
    }

    function isFolderType(typeVal) {
      return normalizeHeader(typeVal) === normalizeHeader('Folder (Folder)');
    }

    function classifyStockRow(vaultMatches, stockKeyBase) {
      if (!vaultMatches || vaultMatches.length === 0) return 'missing';

      const hasFolder = vaultMatches.some(v => isFolderType(v.filetype));
      const hasNonFolder = vaultMatches.some(v => !isFolderType(v.filetype));
      if (hasFolder && !hasNonFolder) return 'folder';

      const idws = vaultMatches.filter(v => v.ext === '.idw');
      if (idws.length) {
        const anyRel = idws.some(v => isReleasedState(v.state));
        return anyRel ? 'released' : 'unreleased';
      }

      if (vaultMatches.some(v => v.ext === '.pdf')) return 'pdf';

      const models = vaultMatches.filter(v => v.ext === '.ipt' || v.ext === '.iam');
      if (models.length) {
        const base = stockKeyBase || '';
        const anyIdwSameBase = vaultMatches.some(v => v.ext === '.idw' && v.base === base);
        if (!anyIdwSameBase) return 'modelled';
      }

      return 'missing';
    }

    function resetCounts() {
      state.audit.counts = {
        released: 0,
        unreleased: 0,
        pdf: 0,
        modelled: 0,
        folder: 0,
        missing: 0,
        totalConsidered: 0,
      };
    }

    function resetReview() {
      state.audit.review.items = [];
      state.audit.review.cursor = 0;
      // keep decisions map across runs unless you want it reset; for now keep it.
      // state.audit.review.decisions = new Map();
    }

    function setReviewStatus(text, kind='muted') {
      if (!el.reviewStatus) return;
      el.reviewStatus.textContent = text;
      el.reviewStatus.className = 'pill ' + (kind === 'ok' ? 'ok' : kind === 'warn' ? 'warn' : kind === 'error' ? 'error' : '');
    }

    function reviewKey(item) {
      // Stable-ish key: stock part code + matched title + rule
      return `${normalizeKey(item.partCode)}|${normalizeKey(item.title)}|${item.rule}`;
    }

    function ensureReviewVisibility() {
      const anyRule = !!state.audit.useDescTitleRule || !!state.audit.useDescTitleTunableRule;
      const hasItems = state.audit.review.items.length > 0;
      if (!el.reviewCard) return;

      if (!anyRule) {
        el.reviewCard.style.display = 'none';
        return;
      }

      el.reviewCard.style.display = 'block';

      if (!hasItems) {
        setReviewStatus('No fuzzy matches', 'warn');
        el.reviewHint.textContent = 'Part Desc ↔ Title rules are enabled, but no matches were produced in the last run.';
        el.reviewNext.disabled = true;
        clearNode(el.reviewList);
        const empty = document.createElement('div');
        empty.className = 'hint muted';
        empty.textContent = 'Nothing to review yet. Try loosening thresholds or running the audit on a wider filter set.';
        el.reviewList.appendChild(empty);
        return;
      }

      setReviewStatus('Ready', 'ok');
      el.reviewNext.disabled = false;
    }

    function renderReviewBatch() {
      ensureReviewVisibility();
      if (!el.reviewCard || el.reviewCard.style.display === 'none') return;

      const items = state.audit.review.items;
      const start = state.audit.review.cursor;
      const end = Math.min(items.length, start + 10);

      clearNode(el.reviewList);

      const hdr = document.createElement('div');
      hdr.className = 'hint';
      hdr.textContent = `Showing ${start + 1}-${end} of ${items.length} fuzzy matches from the last audit run.`;
      el.reviewList.appendChild(hdr);

      for (let i = start; i < end; i++) {
        const it = items[i];
        const key = reviewKey(it);
        const decision = state.audit.review.decisions.get(key) || null;

        const card = document.createElement('div');
        card.className = 'reviewItem';

        const top = document.createElement('div');
        top.className = 'reviewTop';

        const left = document.createElement('div');
        left.style.display = 'flex';
        left.style.gap = '10px';
        left.style.flexWrap = 'wrap';
        left.style.alignItems = 'center';

        const b1 = document.createElement('div');
        b1.className = 'badge';
        b1.textContent = `${it.rule} • shared ${it.shared} • Jaccard ${it.score.toFixed(2)}`;

        const b2 = document.createElement('div');
        b2.className = 'badge';
        b2.textContent = `Part Code: ${it.partCode}`;

        left.appendChild(b1);
        left.appendChild(b2);

        const right = document.createElement('div');
        right.className = 'reviewBtns';

        const approve = document.createElement('button');
        approve.className = 'good';
        approve.textContent = 'Approve';
        approve.disabled = !!decision;
        approve.addEventListener('click', () => {
          state.audit.review.decisions.set(key, 'approved');
          renderReviewBatch();
        });

        const flag = document.createElement('button');
        flag.className = 'bad';
        flag.textContent = 'False positive';
        flag.disabled = !!decision;
        flag.addEventListener('click', () => {
          state.audit.review.decisions.set(key, 'flagged');
          renderReviewBatch();
        });

        if (decision) {
          const d = document.createElement('div');
          d.className = 'decision ' + (decision === 'approved' ? 'approved' : 'flagged');
          d.textContent = decision === 'approved' ? 'Approved' : 'Flagged as false positive';
          right.appendChild(d);
        } else {
          right.appendChild(approve);
          right.appendChild(flag);
        }

        top.appendChild(left);
        top.appendChild(right);
        card.appendChild(top);

        const tokSet = it.tokens || new Set();

        const a = document.createElement('div');
        a.innerHTML = `<div class="reviewLabel">Stock Part Desc</div><div class="reviewText">${highlightTokensInText(it.partDesc, tokSet)}</div>`;

        const b = document.createElement('div');
        b.innerHTML = `<div class="reviewLabel">Vault Title (matched)</div><div class="reviewText">${highlightTokensInText(it.title, tokSet)}</div>`;

        const c = document.createElement('div');
        c.className = 'hint muted';
        const toks = Array.from(tokSet).sort();
        c.textContent = toks.length ? `Matched tokens: ${toks.join(', ')}` : 'Matched tokens: (none)';

        card.appendChild(a);
        card.appendChild(b);
        card.appendChild(c);

        el.reviewList.appendChild(card);
      }

      el.reviewNext.disabled = (end >= items.length);
    }

    function renderAuditCounts() {
      const c = state.audit.counts;
      const rows = [
        { key: 'released', label: 'Released', sub: 'Filetype .idw and State = Released' },
        { key: 'unreleased', label: 'Unreleased', sub: 'Filetype .idw and State ≠ Released' },
        { key: 'pdf', label: 'Only PDF located', sub: 'Filetype .pdf' },
        { key: 'modelled', label: 'Modelled', sub: 'Filetype .ipt/.iam and no .idw' },
        { key: 'folder', label: 'Folder', sub: 'Only Folder (Folder) exists' },
        { key: 'missing', label: 'Missing', sub: 'No matching Vault row found' },
      ];
      el.auditRows.innerHTML = '';
      for (const r of rows) {
        const div = document.createElement('div');
        div.className = 'auditRow';
        div.innerHTML = '<div class="cat">' + r.label + '<span class="subtxt">' + r.sub + '</span></div>' +
                        '<div class="num">' + Number(c[r.key] || 0).toLocaleString() + '</div>';
        el.auditRows.appendChild(div);
      }
    }

    let _auditTimer = null;
    function scheduleAuditRun() {
      if (_auditTimer) clearTimeout(_auditTimer);
      _auditTimer = setTimeout(runAuditNow, 150);
    }

    function runAuditNow() {
      // Requirements: both files loaded
      if (!state.stock.fileName || !state.vault.fileName) {
        setAuditStatus('Waiting for files', 'warn');
        el.auditHint.textContent = 'Load both files to compute results.';
        resetCounts();
        renderAuditCounts();
        return;
      }

      updateAuditMappings();

      // Vault must have Filetype and State columns.
      if (state.audit.vaultTypeIdx === -1 || state.audit.vaultStateIdx === -1) {
        setAuditStatus('Vault export unexpected', 'error');
        el.auditHint.textContent = 'Vault export is missing required columns: Filetype and/or State.';
        log('Vault export is missing required columns. Expected headers: "Filetype" and "State".', 'error');
        return;
      }

      // Determine match columns
      if (state.audit.useDefaultMatchRule) {
        state.audit.stockMatchCol = 'Part Code';
        state.audit.vaultMatchCol = 'Stock Number';
        updateAuditMappings();
      }

      if (state.audit.stockMatchIdx === -1 || state.audit.vaultMatchIdx === -1) {
        setAuditStatus('Missing required match columns', 'error');
        el.auditHint.textContent = 'Cannot run: match column(s) missing.';
        return;
      }

      // Build indexes
      buildVaultIndex();
      if (state.audit.useDescTitleRule || state.audit.useDescTitleTunableRule) buildTitleIndex();

      const filteredStock = getFilteredStockRows();
      resetCounts();
      resetReview();

      let fuzzyUsed = 0;
      let fuzzyUsedTunable = 0;

      for (const r of filteredStock) {
        const stockKey = normalizeKey(safeCell(r, state.audit.stockMatchIdx));
        if (!stockKey) continue;

        let matches = state.audit.vaultIndex.get(stockKey) || [];

        // Secondary fuzzy (conservative)
        if ((!matches || matches.length === 0) && state.audit.useDescTitleRule && state.audit.stockDescIdx !== -1) {
          const desc = safeCell(r, state.audit.stockDescIdx);
          const best = findBestTitleMatch(desc);
          if (best.titleKey) {
            matches = state.audit.titleToEntries.get(best.titleKey) || [];
            if (matches.length) {
              fuzzyUsed++;
              const titleText = (matches[0] && matches[0].name) ? matches[0].name : '';
              const tokSet = overlapTokenSet(desc, titleText);
              state.audit.review.items.push({
                rule: 'Title match',
                partCode: safeCell(r, state.audit.stockMatchIdx),
                partDesc: desc,
                title: titleText,
                shared: best.shared,
                score: best.score,
                tokens: tokSet,
              });
            }
          }
        }

        // Tertiary fuzzy (tunable)
        if ((!matches || matches.length === 0) && state.audit.useDescTitleTunableRule && state.audit.stockDescIdx !== -1) {
          const desc = safeCell(r, state.audit.stockDescIdx);
          const best = findBestTitleMatch(desc, {
            minSharedTokens: Number(state.audit.tunableMinSharedTokens) || FUZZY_MIN_SHARED_TOKENS,
            minJaccard: Number(state.audit.tunableMinJaccard) || FUZZY_MIN_JACCARD,
          });
          if (best.titleKey) {
            matches = state.audit.titleToEntries.get(best.titleKey) || [];
            if (matches.length) {
              fuzzyUsedTunable++;
              const titleText = (matches[0] && matches[0].name) ? matches[0].name : '';
              const tokSet = overlapTokenSet(desc, titleText);
              state.audit.review.items.push({
                rule: 'Tunable match',
                partCode: safeCell(r, state.audit.stockMatchIdx),
                partDesc: desc,
                title: titleText,
                shared: best.shared,
                score: best.score,
                tokens: tokSet,
              });
            }
          }
        }

        const base = baseNameFromAny(stockKey);
        const cat = classifyStockRow(matches, base);
        state.audit.counts[cat] = (state.audit.counts[cat] || 0) + 1;
        state.audit.counts.totalConsidered++;
      }

      renderAuditCounts();

      // Review panel (only relevant if fuzzy rules enabled)
      ensureReviewVisibility();
      if (state.audit.review.items.length) {
        state.audit.review.cursor = 0;
        renderReviewBatch();
      }

      let extra = '';
      if (state.audit.useDescTitleRule) extra += ` (Title matches used: ${fuzzyUsed.toLocaleString()})`;
      if (state.audit.useDescTitleTunableRule) extra += ` (Tunable Title matches used: ${fuzzyUsedTunable.toLocaleString()})`;

      setAuditStatus('Complete', 'ok');
      el.auditHint.textContent = `Considered ${state.audit.counts.totalConsidered.toLocaleString()} stock rows after filters.${extra}`;
    }

    // -----------------------------
    // Rules panel wiring
    // -----------------------------
    function buildSelectOptions(selectEl, headers, preferredHeader) {
      selectEl.innerHTML = '';
      for (const h of headers) {
        const opt = document.createElement('option');
        opt.value = h;
        opt.textContent = h || '(blank)';
        if (preferredHeader && normalizeHeader(h) === normalizeHeader(preferredHeader)) opt.selected = true;
        selectEl.appendChild(opt);
      }
    }

    function refreshRulesAvailability() {
      const hasStock = state.stock.headers.length > 0;
      const hasVault = state.vault.headers.length > 0;
      const ready = hasStock && hasVault;

      el.toggleRules.disabled = !ready;
      el.runAudit.disabled = !ready;

      if (!ready) return;

      updateAuditMappings();

      // Validate fixed vault columns
      const fixedTypeIdx = findColumnIndex(state.vault.headers, 'Filetype');
      const fixedStateIdx = findColumnIndex(state.vault.headers, 'State');
      if (fixedTypeIdx === -1 || fixedStateIdx === -1) {
        setAuditStatus('Vault export unexpected', 'error');
        el.runAudit.disabled = true;
        log('Vault export is missing required columns. Expected headers: "Filetype" and "State".', 'error');
      }

      // Populate manual drop-downs
      buildSelectOptions(el.stockMatchCol, state.stock.headers, state.audit.stockMatchCol);
      buildSelectOptions(el.vaultMatchCol, state.vault.headers, state.audit.vaultMatchCol);

      // Enable/disable manual grid based on default toggle
      const useDefault = !!el.defaultMatchToggle.checked;
      state.audit.useDefaultMatchRule = useDefault;
      el.stockMatchCol.disabled = useDefault;
      el.vaultMatchCol.disabled = useDefault;

      if (useDefault) {
        state.audit.stockMatchCol = 'Part Code';
        state.audit.vaultMatchCol = 'Stock Number';
      } else {
        state.audit.stockMatchCol = el.stockMatchCol.value || state.audit.stockMatchCol;
        state.audit.vaultMatchCol = el.vaultMatchCol.value || state.audit.vaultMatchCol;
      }

      // Desc↔Title prerequisites
      const canUseDescTitle = (findColumnIndex(state.stock.headers, 'Part Desc') !== -1) && (findColumnIndex(state.vault.headers, 'Title') !== -1);
      el.descTitleToggle.disabled = !canUseDescTitle;
      el.descTitleTunableToggle.disabled = !canUseDescTitle;
      if (!canUseDescTitle) {
        el.descTitleToggle.checked = false;
        el.descTitleTunableToggle.checked = false;
        state.audit.useDescTitleRule = false;
        state.audit.useDescTitleTunableRule = false;
      } else {
        state.audit.useDescTitleRule = !!el.descTitleToggle.checked;
        state.audit.useDescTitleTunableRule = !!el.descTitleTunableToggle.checked;
      }

      // Sync sliders
      el.tunableTok.value = String(state.audit.tunableMinSharedTokens);
      el.tunableJac.value = String(state.audit.tunableMinJaccard);
      el.tunableTokVal.textContent = String(state.audit.tunableMinSharedTokens);
      el.tunableJacVal.textContent = Number(state.audit.tunableMinJaccard).toFixed(2);
      el.tunableControls.style.display = state.audit.useDescTitleTunableRule ? 'grid' : 'none';

      // Meta labels
      el.defaultMatchMeta.textContent = useDefault
        ? 'Active. Matching is exact after trimming and lowercasing (case-insensitive).'
        : 'Off. Using manual match columns below.';

      el.descTitleMeta.textContent = !canUseDescTitle
        ? 'Unavailable. Requires Stock column "Part Desc" and Vault column "Title".'
        : (state.audit.useDescTitleRule
          ? `On. Using loose word match (min shared tokens ${FUZZY_MIN_SHARED_TOKENS}, min Jaccard ${FUZZY_MIN_JACCARD}).`
          : 'Off. If enabled, rows that fail the default match will try a word-overlap match between Stock Part Desc and Vault Title.');

      el.descTitleTunableMeta.textContent = !canUseDescTitle
        ? 'Unavailable. Requires Stock column "Part Desc" and Vault column "Title".'
        : (state.audit.useDescTitleTunableRule
          ? `On. Using tunable loose word match (min shared tokens ${state.audit.tunableMinSharedTokens}, min Jaccard ${Number(state.audit.tunableMinJaccard).toFixed(2)}).`
          : 'Off. If enabled, uses the sliders below to try to reduce false negatives (may increase false positives).');

      scheduleAuditRun();
    }

    // -----------------------------
    // Event handlers
    // -----------------------------
    el.toggleRules.addEventListener('click', () => {
      const isOpen = el.rulesPanel.style.display !== 'none';
      el.rulesPanel.style.display = isOpen ? 'none' : 'block';
    });

    el.defaultMatchToggle.addEventListener('change', () => {
      refreshRulesAvailability();
        ensureReviewVisibility();
    });

    el.stockMatchCol.addEventListener('change', () => {
      if (state.audit.useDefaultMatchRule) return;
      state.audit.stockMatchCol = el.stockMatchCol.value;
      refreshRulesAvailability();
    });

    el.vaultMatchCol.addEventListener('change', () => {
      if (state.audit.useDefaultMatchRule) return;
      state.audit.vaultMatchCol = el.vaultMatchCol.value;
      refreshRulesAvailability();
    });

    el.descTitleToggle.addEventListener('change', () => {
      state.audit.useDescTitleRule = !!el.descTitleToggle.checked;
      refreshRulesAvailability();
    });

    el.descTitleTunableToggle.addEventListener('change', () => {
      state.audit.useDescTitleTunableRule = !!el.descTitleTunableToggle.checked;
      el.tunableControls.style.display = state.audit.useDescTitleTunableRule ? 'grid' : 'none';
      refreshRulesAvailability();
    });

    function onTunableChanged() {
      state.audit.tunableMinSharedTokens = Number(el.tunableTok.value);
      state.audit.tunableMinJaccard = Number(el.tunableJac.value);
      el.tunableTokVal.textContent = String(state.audit.tunableMinSharedTokens);
      el.tunableJacVal.textContent = Number(state.audit.tunableMinJaccard).toFixed(2);
      if (state.audit.useDescTitleTunableRule) {
        el.descTitleTunableMeta.textContent = `On. Using tunable loose word match (min shared tokens ${state.audit.tunableMinSharedTokens}, min Jaccard ${Number(state.audit.tunableMinJaccard).toFixed(2)}).`;
      }
      scheduleAuditRun();
    }

    el.tunableTok.addEventListener('input', onTunableChanged);
    el.tunableJac.addEventListener('input', onTunableChanged);

    // Review: pagination
    if (el.reviewNext) {
      el.reviewNext.addEventListener('click', () => {
        const items = state.audit.review.items;
        if (!items.length) return;
        state.audit.review.cursor = Math.min(items.length, state.audit.review.cursor + 10);
        if (state.audit.review.cursor >= items.length) {
          state.audit.review.cursor = Math.max(0, items.length - 10);
        }
        renderReviewBatch();
      });
    }

    el.runAudit.addEventListener('click', runAuditNow);

    el.groupSearch.addEventListener('input', renderGroupList);

    el.selectAll.addEventListener('click', () => {
      for (const g of state.stock.groupSelected.keys()) state.stock.groupSelected.set(g, true);
      renderGroupList();
      scheduleAuditRun();
    });

    el.selectNone.addEventListener('click', () => {
      for (const g of state.stock.groupSelected.keys()) state.stock.groupSelected.set(g, false);
      renderGroupList();
      scheduleAuditRun();
    });

    el.selectDefault.addEventListener('click', () => {
      const out = applyDefaultGroupSelection();
      renderGroupList();
      log(`Default selection applied. ${out.selected} Group Desc values ticked.`, 'info');
      scheduleAuditRun();
    });

    // Date filter events
    el.f6m.addEventListener('change', () => setDateFilterMode(el.f6m.checked ? '6m' : 'none'));
    el.f12m.addEventListener('change', () => setDateFilterMode(el.f12m.checked ? '12m' : 'none'));
    el.fcustom.addEventListener('change', () => setDateFilterMode(el.fcustom.checked ? 'custom' : 'none'));
    el.fStart.addEventListener('change', () => { updateDateFilterRange(); scheduleAuditRun(); });
    el.fEnd.addEventListener('change', () => { updateDateFilterRange(); scheduleAuditRun(); });

    // -----------------------------
    // File loading
    // -----------------------------
    el.stockFile.addEventListener('change', async () => {
      const file = el.stockFile.files && el.stockFile.files[0];
      if (!file) return;

      try {
        setStatus('stock', 'Loading…', 'warn');
        const { headers, rows, sheet } = await readXlsx(file);
        state.stock.fileName = file.name;
        state.stock.headers = headers;

        // Option B: Only keep rows where Part Code is non-empty
        const pcIdx = findColumnIndex(headers, 'Part Code');
        const filtered = filterRowsByRequiredColumn(rows, pcIdx);
        state.stock.rawRows = filtered.rows;
        state.stock.rows = filtered.rows;

        if (filtered.dropped) {
          log(`Dropped ${filtered.dropped.toLocaleString()} stock rows with empty Part Code.`, 'info');
        }

        renderChips(el.stockHeaders, headers);

        // Enable date controls
        const dateIdx = findColumnIndex(headers, 'Last Movement Date');
        el.f6m.disabled = (dateIdx === -1);
        el.f12m.disabled = (dateIdx === -1);
        el.fcustom.disabled = (dateIdx === -1);
        el.fStart.disabled = true;
        el.fEnd.disabled = true;
        state.stock.dateFilter.mode = 'none';
        el.f6m.checked = false;
        el.f12m.checked = false;
        el.fcustom.checked = false;
        el.fStart.value = '';
        el.fEnd.value = '';
        el.fMeta.textContent = (dateIdx === -1)
          ? 'Column "Last Movement Date" not found — date filtering unavailable.'
          : 'No date filtering applied.';

        // Group Desc summary
        const gIdx = findColumnIndex(headers, 'Group Desc');
        state.stock.groupCounts = computeCounts(state.stock.rows, gIdx);
        rebuildGroupSelectionDefaultAll();

        // Enable group UI
        const hasGroups = state.stock.groupCounts.size > 0;
        el.groupSearch.disabled = !hasGroups;
        el.selectAll.disabled = !hasGroups;
        el.selectNone.disabled = !hasGroups;
        el.selectDefault.disabled = !hasGroups;

        renderGroupList();

        setStatus('stock', `Loaded (${sheet}) — ${state.stock.rows.length.toLocaleString()} rows`, 'ok');
        log(`Stock file loaded. Headers: ${headers.length}. Rows (with Part Code): ${state.stock.rows.length}. Unique Group Desc: ${state.stock.groupCounts.size}.`, 'info');

        refreshRulesAvailability();
      } catch (e) {
        console.error(e);
        setStatus('stock', 'Failed to load', 'error');
        log(`Failed to parse stock XLSX: ${e && e.message ? e.message : e}`, 'error');
      }
    });

    el.vaultFile.addEventListener('change', async () => {
      const file = el.vaultFile.files && el.vaultFile.files[0];
      if (!file) return;

      try {
        setStatus('vault', 'Loading…', 'warn');
        const { headers, rows, sheet } = await readXlsx(file);
        state.vault.fileName = file.name;
        state.vault.headers = headers;
        state.vault.rows = rows;

        renderChips(el.vaultHeaders, headers);
        renderVaultFiletypeSummary();

        setStatus('vault', `Loaded (${sheet}) — ${rows.length.toLocaleString()} rows`, 'ok');
        log(`Vault file loaded. Headers: ${headers.length}. Rows: ${rows.length}.`, 'info');

        refreshRulesAvailability();
      } catch (e) {
        console.error(e);
        setStatus('vault', 'Failed to load', 'error');
        log(`Failed to parse vault XLSX: ${e && e.message ? e.message : e}`, 'error');
      }
    });

    // -----------------------------
    // Self-tests
    // -----------------------------
    function runSelfTests() {
      const tests = [];
      const t = (name, fn) => tests.push({ name, fn });

      t('stripPath handles backslashes', () => stripPath('C\\\\a\\\\b\\\\file.idw') === 'file.idw');
      t('stripPath trims whitespace', () => stripPath('  C\\\\a\\\\b\\\\file.idw  ') === 'file.idw');
      t('normalizeKey is case-insensitive', () => normalizeKey('AbC123') === 'abc123');
      t('baseNameFromAny drops ext', () => baseNameFromAny('a/b/Thing.IDW') === 'thing');
      t('detectExt finds idw in filetype', () => detectExt('Autodesk Inventor Drawing (.idw)', 'Thing') === '.idw');
      t('detectExt finds pdf in name', () => detectExt('', 'ABC.PDF') === '.pdf');

      t('parseLooseDate parses dd/mm/yyyy', () => {
        const d = parseLooseDate('13/01/2026');
        return !!d && d.getUTCFullYear() === 2026;
      });

      t('filterRowsByRequiredColumn drops empty Part Code rows', () => {
        const rows = [['A'], [''], ['  '], ['B']];
        const r = filterRowsByRequiredColumn(rows, 0);
        return r.rows.length === 2 && r.dropped === 2;
      });

      t('tokenizeLoose keeps m12 and drops stopwords', () => {
        const toks = tokenizeLoose('The M12 bolt and nut');
        return toks.includes('m12') && toks.includes('bolt') && toks.includes('nut') && !toks.includes('the') && !toks.includes('and');
      });

      t('tokenizeLoose splits mixed alphanumerics', () => {
        const toks = tokenizeLoose('Plate 150mm wide');
        return toks.includes('plate') && toks.includes('150') && toks.includes('wide');
      });

      t('findBestTitleMatch picks obvious overlap', () => {
        const prevTok = state.audit.titleTokenIndex;
        const prevMap = state.audit.titleToEntries;
        state.audit.titleTokenIndex = new Map();
        state.audit.titleToEntries = new Map();

        const addTitle = (title) => {
          const k = normalizeKey(title);
          state.audit.titleToEntries.set(k, [{ name: title, ext: '.pdf', filetype: '.pdf', state: '' }]);
          for (const tok of unique(tokenizeLoose(title))) {
            if (!state.audit.titleTokenIndex.has(tok)) state.audit.titleTokenIndex.set(tok, new Set());
            state.audit.titleTokenIndex.get(tok).add(k);
          }
        };
        addTitle('M12 Bolt Assembly 150mm');
        addTitle('Hydraulic Hose Kit');

        const best = findBestTitleMatch('Bolt assembly M12 150 mm');
        const ok = !!best.titleKey && best.titleKey.includes('m12 bolt assembly');

        state.audit.titleTokenIndex = prevTok;
        state.audit.titleToEntries = prevMap;
        return ok;
      });

      t('findBestTitleMatch accepts looser thresholds when supplied', () => {
        const prevTok = state.audit.titleTokenIndex;
        const prevMap = state.audit.titleToEntries;
        state.audit.titleTokenIndex = new Map();
        state.audit.titleToEntries = new Map();

        const addTitle = (title) => {
          const k = normalizeKey(title);
          state.audit.titleToEntries.set(k, [{ name: title, ext: '.pdf', filetype: '.pdf', state: '' }]);
          for (const tok of unique(tokenizeLoose(title))) {
            if (!state.audit.titleTokenIndex.has(tok)) state.audit.titleTokenIndex.set(tok, new Set());
            state.audit.titleTokenIndex.get(tok).add(k);
          }
        };
        addTitle('Hydraulic Hose Kit');

        const best = findBestTitleMatch('Hydraulic kit', { minSharedTokens: 2, minJaccard: 0.20 });
        const ok = !!best.titleKey;

        state.audit.titleTokenIndex = prevTok;
        state.audit.titleToEntries = prevMap;
        return ok;
      });

      t('highlightTokensInText highlights only whole alnum tokens', () => {
        const s = 'M12 bolt - bolt.';
        const set = new Set(['m12','bolt']);
        const out = highlightTokensInText(s, set);
        return out.includes('<mark') && out.toLowerCase().includes('m12') && out.toLowerCase().includes('bolt');
      });

      let pass = 0;
      for (const test of tests) {
        let ok = false;
        try {
          ok = !!test.fn();
        } catch (e) {
          ok = false;
        }
        if (!ok) {
          log(`Self-test failed: ${test.name}`, 'warn');
        } else {
          pass++;
        }
      }

      if (pass !== tests.length) {
        log(`Self-tests: ${pass}/${tests.length} passed`, 'warn');
      } else {
        log(`Self-tests: ${pass}/${tests.length} passed`, 'info');
      }
    }

    // Boot
    renderAuditCounts();
    renderVaultFiletypeSummary();
    ensureReviewVisibility();
    runSelfTests();
    log('Ready. Load your XLSX files to begin.', 'info');
  </script>
</body>
</html>
